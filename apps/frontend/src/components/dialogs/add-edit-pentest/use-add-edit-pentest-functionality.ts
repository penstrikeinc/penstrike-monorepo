import { UseFormReturn } from 'react-hook-form';
import { Dispatch, MouseEventHandler, SetStateAction, useCallback, useEffect } from 'react';
import { AxiosResponse } from 'axios';
import { pentestDefaultValues, TAssets, TPentest } from 'src/schemas';
import { ICompletedStateProps } from './step-components/type';

export interface IParams {
  onClose: () => void;
  isEditMode: boolean;
  activeStep: number;
  setActiveStep: Dispatch<SetStateAction<number>>;
  setCompleted: Dispatch<SetStateAction<ICompletedStateProps>>;
  onSuccess?: (data: AxiosResponse<any>) => void;
  onError?: (error: unknown) => void;
  completed: ICompletedStateProps;
  methods: UseFormReturn<TPentest>;
  assetMethods: UseFormReturn<TAssets>;
}

export const useAddEditPentestFunctionality = (params: IParams) => {
  const {
    onClose,
    isEditMode,
    activeStep,
    setActiveStep,
    setCompleted,
    onSuccess,
    onError,
    completed,
    methods,
    assetMethods,
  } = params;

  const {
    reset,
    formState: { isValid },
  } = methods;
  const {
    formState: { isValid: isValidAsset },
  } = assetMethods;

  const isMutationLoading = false;

  const isValidForm = isValid;
  const isValidAssets = isValidAsset;
  const isDisabled = Boolean(!isValidForm || !isValidAssets);
  // const isErrorsForm = false;

  const onCloseHandler = useCallback(() => {
    reset(pentestDefaultValues);
    setActiveStep(0);
    setCompleted({});
    onClose();
  }, [onClose, reset, setActiveStep, setCompleted]);

  const handleComplete = useCallback(() => {
    const newCompleted = completed;

    if (isValidForm) {
      newCompleted[0] = true;
    }
    if (isValidAssets) {
      newCompleted[1] = true;
    }
    // if (isErrorsForm) {
    //   newCompleted[0] = false;
    //   newCompleted[2] = false;
    // }
    // if (!isDisabled && !isErrorsForm) {
    //   newCompleted[0] = true;
    //   newCompleted[1] = true;
    //   newCompleted[2] = true;
    // }
    if (!isDisabled) {
      newCompleted[0] = true;
      newCompleted[1] = true;
      newCompleted[2] = true;
    }

    setCompleted(newCompleted);
  }, [completed, isDisabled, isValidAssets, isValidForm, setCompleted]);

  useEffect(() => {
    if (isEditMode) {
      handleComplete();
    }
    // else if (isErrorsForm) {
    //   handleComplete();
    // }
  }, [handleComplete, isEditMode]);

  const onUpdateSupplierSubmit = useCallback(async (data: any) => {}, []);

  const onCreateSupplierSubmit = useCallback(async (data: any) => {}, []);

  const handleNext = useCallback(() => {
    setActiveStep(activeStep + 1);
    handleComplete();
  }, [activeStep, handleComplete, setActiveStep]);

  const handleBack = useCallback(() => {
    setActiveStep((prevActiveStep: number) => prevActiveStep - 1);
    handleComplete();
  }, [handleComplete, setActiveStep]);

  const handleStep = useCallback(
    (step: number) => () => {
      if (step !== 2 || isEditMode || !isDisabled) {
        setActiveStep(step);
      } else {
        // Swal.fire({
        //   title: t('alert.dialog_incomplete_step.title'),
        //   text: t('alert.dialog_incomplete_step.description'),
        //   showConfirmButton: false,
        // });
      }
      handleComplete();
    },
    [handleComplete, isDisabled, isEditMode, setActiveStep]
  );

  const onCloseDialogHandler = useCallback(
    (_event: MouseEventHandler<HTMLButtonElement>, reason: 'escapeKeyDown' | 'backdropClick') => {
      if (reason === 'backdropClick') {
        return;
      }
      onCloseHandler();
    },
    [onCloseHandler]
  );

  const onSubmit = isEditMode ? onUpdateSupplierSubmit : onCreateSupplierSubmit;

  return {
    onSubmit,
    onCloseHandler,
    onCloseDialogHandler,
    methods,
    handleBack,
    handleNext,
    handleStep,
    isDisabled,
    isMutationLoading,
  };
};
